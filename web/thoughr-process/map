# Intelligent Video Compilation Platform - Technical Flow Map

## üéØ System Overview
Transform passive video archives into an active, searchable, creative canvas through AI analysis and natural language processing.

**Core Philosophy**: Upload ‚Üí AI Analysis ‚Üí Natural Language Search ‚Üí Automated Video Compilation

---

## üèóÔ∏è Google Cloud Platform Architecture

**Next.js Full-Stack App on Cloud Run**
           ‚Üï
**Firebase Auth** ‚Üî **Firestore** ‚Üî **Cloud Storage** ‚Üî **AI Pipeline**

### Complete Tech Stack
- **Framework**: Next.js 14 with TypeScript
- **Frontend**: React components with Tailwind CSS
- **Backend**: Next.js API routes (serverless functions)
- **Hosting**: Google Cloud Run (auto-scaling containers)
- **Authentication**: Firebase Auth (Google OAuth + email/password)
- **Database**: Firestore (real-time, user data, upload sessions)
- **Storage**: Cloud Storage (video files)
- **AI Services**: Video Intelligence API + Speech-to-Text API
- **State Management**: React Context API
- **Package Manager**: npm

---

## üìã Phase 1: Authentication & User Management

### 1.1 Landing Page Flow
1. **Homepage**: Minimal, clean interface explaining the platform value
   - Hero section: "Upload videos, search with AI, create compilations"
   - Two main CTAs: "Sign Up" and "Sign In" buttons
   - Simple, professional design with Tailwind CSS
2. **No Guest Access**: All features require authentication for cross-device persistence

### 1.2 Authentication System
**Sign Up Flow**:
1. User clicks "Sign Up" ‚Üí Sign up form page
2. **Two Options**:
   - Google OAuth (one-click, recommended)
   - Email/password form (email, password, confirm password)
3. **Account Creation**: Create user document in Firestore
4. **Redirect**: Successful signup ‚Üí Upload page (Phase 2)

**Sign In Flow**:
1. User clicks "Sign In" ‚Üí Sign in form page  
2. **Two Options**:
   - Google OAuth
   - Email/password form
3. **Authentication**: Firebase Auth validation
4. **Redirect**: Successful login ‚Üí Upload page (Phase 2)

**Forgot Password Flow**:
1. "Forgot Password?" link on sign in page
2. Email input form
3. Firebase sends password reset email
4. User resets password via email link
5. Redirect back to sign in page

### 1.3 Database Schema (Firestore)

**Users Collection** (`users/{userId}`):
```json
{
  "uid": "firebase_user_id",
  "email": "user@example.com", 
  "authProvider": "google" | "email",
  "createdAt": "timestamp",
  "lastLoginAt": "timestamp",
}
```

### 1.4 UI Components Structure
**Pages**:
- `/` - Landing page with auth CTAs
- `/auth/signup` - Sign up form  
- `/auth/signin` - Sign in form
- `/auth/forgot-password` - Password reset form
- `/upload` - Main upload interface (Phase 2)

**Components**:
- `AuthLayout` - Shared layout for auth pages
- `SignUpForm` - Email/password + Google OAuth signup
- `SignInForm` - Email/password + Google OAuth signin  
- `ForgotPasswordForm` - Password reset request
- `AuthProvider` - Context for auth state management

### 1.5 Navigation Flow
```
Homepage (/) 
    ‚îú‚îÄ‚îÄ Sign Up ‚Üí /auth/signup ‚Üí Account Creation ‚Üí /upload
    ‚îú‚îÄ‚îÄ Sign In ‚Üí /auth/signin ‚Üí Authentication ‚Üí /upload
    ‚îî‚îÄ‚îÄ Sign In ‚Üí Forgot Password ‚Üí /auth/forgot-password ‚Üí Email Sent ‚Üí /auth/signin
```

### 1.6 Authentication State Management
- **Firebase Auth**: Handles all authentication logic
- **React Context**: `AuthProvider` wraps entire app
- **Route Protection**: Upload page requires authentication
- **Persistent Sessions**: Users stay logged in across browser sessions
- **Auto-redirect**: Authenticated users accessing auth pages redirect to /upload

### Key Benefits of This Architecture
- **Cross-device continuity**: Users can switch devices seamlessly
- **Secure by default**: All video data tied to authenticated users
- **Scalable auth**: Firebase handles user management automatically
- **Simple UX**: Minimal friction to get users into the main upload flow
- **Future-ready**: Database structure supports Phase 2 video AI features

---

## üìã Phase 2: Upload & Initial Processing

### 1.1 Upload Initiation Flow
1. **User Authentication Check**: Verify user is signed in
2. **File Selection**: Drag & drop or file picker interface
3. **File Validation**: Check type, size, and user quota limits
4. **Adaptive Chunking**: Determine optimal chunk size based on file size
   - Small files (< 1GB): 5MB chunks
   - Medium files (1-10GB): 10MB chunks  
   - Large files (> 10GB): 20MB chunks
5. **Upload Session Creation**: Generate unique video ID and save to Firestore

### 1.2 Secure Upload URL Generation
1. **Cloud Function Trigger**: Frontend requests upload URLs
2. **User Verification**: Validate JWT token and user permissions
3. **Signed URL Creation**: Generate time-limited upload URLs for each chunk
4. **Session Storage**: Save upload session details to Firestore
5. **URL Response**: Return array of signed URLs to frontend

### 1.3 Direct Upload Process
1. **Parallel Chunk Upload**: Upload multiple chunks simultaneously to Cloud Storage
2. **Real-time Progress**: Update UI and Firestore after each successful chunk
3. **Error Handling**: Retry failed chunks with exponential backoff
4. **State Persistence**: All progress saved to Firestore (not localStorage)
5. **Resume Capability**: Users can continue from any device/browser

### 1.4 Upload Completion & Reassembly
1. **Completion Verification**: Check all chunks uploaded successfully
2. **Cloud Function Trigger**: Frontend calls finalize endpoint
3. **Chunk Verification**: Verify all chunks exist in Cloud Storage
4. **Video Reassembly**: Use Cloud Storage compose operation to merge chunks
5. **Status Update**: Mark video as ready for processing in Firestore
6. **Pipeline Trigger**: Initiate AI analysis phase

### 1.5 Video Library Interface Flow
1. **Library Access**: Floating toggle button at bottom of upload page
2. **Library Overlay**: Slides up as modal overlay (doesn't navigate away)
3. **Card Generation**: Query Firestore for user's videos, render as cards
4. **Real-time Updates**: Subscribe to Firestore changes for live status updates
5. **Card Display**: Each card shows video name + visual status indicator

### 1.6 Video Library Status System
**Status Indicators**:
- **Uploading**: Progress ring with percentage + upload arrow icon
- **Paused/Failed**: Red warning icon with retry option
- **Processing**: Spinning gear icon (video reassembly/AI analysis)
- **Completed**: Green checkmark with play button

**Card Information**:
- Video display name (user can rename inline)
- Upload date/time
- File size
- Current status with appropriate icon
- Progress bar (if uploading/processing)

### 1.7 Library Data Flow
1. **Firestore Query**: Get all videos where `userId == currentUser.uid`
2. **Status Mapping**: Map database status to UI indicator
3. **Real-time Sync**: Firestore onSnapshot listener updates cards instantly
4. **User Actions**: Rename video ‚Üí Update Firestore ‚Üí UI reflects change
5. **Upload Resume**: Click paused upload ‚Üí Resume chunked upload process

### 1.8 Library UI Behavior
- **Responsive Grid**: Cards arranged in responsive grid layout
- **Inline Editing**: Click video name to rename (saves to Firestore)
- **Status Actions**: Click status indicator for relevant actions (retry, resume, etc.)
- **Auto-refresh**: Library updates automatically as uploads progress
- **Close Library**: Click outside overlay or toggle button to close

### Key Features
- **Cross-device resume**: Upload state saved to user's cloud account
- **Intelligent retry**: Failed chunks automatically retried
- **Cost optimization**: Direct upload to storage (bypasses function data limits)
- **Security**: Time-limited signed URLs, user authentication required
- **Scalability**: Handles 5-minute to 12-hour videos efficiently
- **Real-time library**: Video cards update live during upload/processing

---

## üìã Phase 2: AI Analysis Pipeline (Future)

### Video Processing Flow
1. **Transcoding**: Convert to standard format for AI analysis
2. **Visual Analysis**: Video Intelligence API extracts objects, scenes, actions
3. **Audio Analysis**: Speech-to-Text API creates timestamped transcripts
4. **Data Aggregation**: Combine visual and audio analysis into searchable scenes
5. **Vector Embedding**: Convert scene descriptions to semantic vectors
6. **Database Storage**: Save structured metadata to Firestore

---

## üìã Phase 3: Search & Compilation (Future)

### User Search Flow
1. **Natural Language Query**: User types "exciting goal moments"
2. **Semantic Search**: Convert query to vector, find matching scenes
3. **Director Algorithm**: Select best scenes within time constraints  
4. **Video Compilation**: Extract and stitch scenes using FFmpeg
5. **Delivery**: Present compiled video to user

---

## üîÑ Cross-Phase Considerations

### Data Flow Principles
- **User-Centric**: All data tied to authenticated user accounts
- **Resumable**: Every long-running process can be interrupted and resumed
- **Real-time**: UI updates immediately reflect backend state changes
- **Secure**: All operations require authentication and authorization
- **Cost-Efficient**: Direct storage uploads, serverless compute
- **Scalable**: Architecture handles 1 user or 10,000 users identically

### Error Handling Strategy
- **Graceful Degradation**: System works with partial failures
- **User Communication**: Clear error messages and recovery options
- **Automatic Retry**: Exponential backoff for transient failures
- **Manual Recovery**: Admin tools for stuck processes
- **Monitoring**: Real-time alerts for system issues

### Security Considerations
- **Authentication**: Firebase Auth with social login options
- **Authorization**: User can only access their own content
- **Data Privacy**: Upload sessions and videos tied to user accounts
- **Content Validation**: File type and size restrictions enforced
- **Rate Limiting**: Prevent abuse with quota systems

---

*This map provides the logical flow and decision points for each phase. Detailed implementation code is maintained in the todo file.*
